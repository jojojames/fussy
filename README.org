#+TITLE: Fussy
#+STARTUP: noindent

This is a package to provide a ~completion-style~ to Emacs that leverages [[https://github.com/lewang/flx][flx]].

* Installation

- Get the package, either from MELPA (soon to come):

  : M-x package-install RET fussy RET
  Or clone / download this repository and modify your ~load-path~:

  #+begin_src emacs-lisp :tangle yes
  (add-to-list 'load-path (expand-file-name "/path/to/fussy/" user-emacs-directory))
  #+end_src
* Straight Example

#+begin_src emacs-lisp :tangle yes
  (use-package fussy
    :ensure t
    :straight
    (fussy :type git :host github :repo "jojojames/fussy")
    :config
    (push 'fussy completion-styles)
    (setq
     ;; For example, project-find-file uses 'project-files which uses
     ;; substring completion by default. Set to nil to make sure it's using
     ;; flx.
     completion-category-defaults nil
     completion-category-overrides nil))
#+end_src

* Scoring Backends
We default to [[https://github.com/lewang/flx][flx]] for scoring matches but additional scoring functions/backends
can be used.
** Flx
[[https://github.com/lewang/flx][flx]] is a dependency of ~fussy~ and the default
scoring algorithm.

We can leverage [[https://github.com/jcs-elpa/flx-rs][flx-rs]] to achieve faster
scoring by using Rust. This library matches the original
[[https://github.com/lewang/flx][flx]] implementation.

#+begin_src emacs-lisp :tangle yes
  (use-package flx-rs
    :ensure t
    :straight
    (flx-rs
     :repo "jcs-elpa/flx-rs"
     :fetcher github
     :files (:defaults "bin"))
    :config
    (setq fussy-score-fn 'flx-rs-score)
    (flx-rs-load-dyn))
#+end_src

** Fuz
Another option is to use the [[https://github.com/rustify-emacs/fuz.el][fuz]]
library (also in Rust) for scoring.

This library has two fuzzy matching algorithms, ~skim~ and ~clangd~.

Skim: Just like [[https://github.com/junegunn/fzf][fzf]] v2, the algorithm is
based on Smith-Waterman algorithm which is normally used in DNA sequence alignment

Clangd: The algorithm is based on clangd's
[[https://github.com/MaskRay/ccls/blob/master/src/fuzzy_match.cc][FuzzyMatch.cpp]].

For more information: [[https://github.com/lotabout/fuzzy-matcher][fuzzy-matcher]]

#+begin_src emacs-lisp :tangle yes
  (use-package fuz
    :ensure nil
    :after flx
    :straight (fuz :type git :host github :repo "rustify-emacs/fuz.el")
    :config
    (setq fussy-score-fn 'fussy-fuz-score)
    (unless (require 'fuz-core nil t)
      (fuz-build-and-load-dymod)))
#+end_src

#+begin_src emacs-lisp :tangle yes
  ;; Same as fuz but with prebuilt binaries.
  (use-package fuz-bin
    :ensure t
    :straight
    (fuz-bin
     :repo "jcs-elpa/fuz-bin"
     :fetcher github
     :files (:defaults "bin"))
    :config
    (setq fussy-score-fn 'fussy-fuz-bin-score)
    (fuz-bin-load-dyn))
#+end_src
** Liquid Metal
A mimetic poly-alloy of the Quicksilver scoring algorithm,
essentially LiquidMetal.

Flex matching short abbreviations against longer strings is a boon in
productivity for typists.  Applications like Quicksilver, Alfred, LaunchBar, and
Launchy have made this method of keyboard entry a popular one. It's time to
bring this same functionality to web controls. LiquidMetal makes scoring long
strings against abbreviations easy.

For more information: [[https://github.com/rmm5t/liquidmetal][liquidmetal]]

#+begin_src emacs-lisp :tangle yes
  (use-package liquidmetal
    :ensure t
    :straight t
    (setq fussy-score-fn 'fussy-liquidmetal-score))
#+end_src

** Sublime-Fuzzy

Fuzzy matching algorithm based on Sublime Text's string search.
Iterates through characters of a search string and calculates a score.
This is another fuzzy implementation written in Rust.

For more information: [[https://github.com/Schlechtwetterfront/fuzzy-rs][fuzzy-rs]]

#+begin_src emacs-lisp :tangle yes
  (use-package sublime-fuzzy
    :ensure t
    :straight
    (sublime-fuzzy
     :repo "jcs-elpa/sublime-fuzzy"
     :fetcher github
     :files (:defaults "bin"))
    :config
    (setq fussy-score-fn 'fussy-sublime-fuzzy-score)
    (sublime-fuzzy-load-dyn))
#+end_src

* Company Integration
Fuzzy completion may or may not be too slow when completing with
[[https://github.com/company-mode/company-mode][company-mode]].

For this, we can advise ~company-capf~ to use basic completions.

#+begin_src emacs-lisp :tangle yes

  (defconst OG-COMPLETION-STYLES completion-styles
    "Original `completion-styles' Emacs comes with.")

  (defun company-capf-with-og-completion-styles (f &rest args)
    "Set `completion-styles' to be the default Emacs `completion-styles'
  while `company-capf' runs."
    (let ((completion-styles OG-COMPLETION-STYLES))
      (apply f args)))

  (advice-add 'company-capf :around 'company-capf-with-og-completion-styles)
#+end_src

If you don't use the above advice and want to use fuzzy completion, you can
use the below ~company-transformer~.

#+begin_src emacs-lisp :tangle yes
  (setq company-transformers
        '(fussy-company-sort-by-completion-score))
#+end_src
* Eglot Integration

Eglot by default uses ~flex~ in ~completion-category-defaults~.
Use this to override that.

#+begin_src emacs-lisp :tangle yes
  (with-eval-after-load 'eglot
    (add-to-list 'completion-category-overrides
                 '(eglot (styles fussy basic))))
#+end_src

* Orderless Integration

[[https://github.com/oantolin/orderless][orderless]] can be used for filtering.

Quick eyetest benchmarking yields about a 20~ms improvement.

e.g.

#+begin_src emacs-lisp :tangle yes

  (fussy--measure-time
   (funcall fussy-filter-fn
            string table pred point))

  ;; M-x describe-symbol (30000~ candidates)

  ;; Flex
  ;; (setq fussy-filter-fn 'fussy-filter-flex)
  ;; Type letter a
  ;; 0.114714
  ;; Type letter b
  ;; 0.071597
  ;; Type letter c
  ;; 0.096974
  ;; Type letter d
  ;; 0.092788
  ;; Type letter e
  ;; 0.124994
  ;; Type letter f
  ;; 0.077074
  ;; Type letter g
  ;; 0.090732

  ;; Orderless
  ;; (setq fussy-filter-fn 'fussy-filter-orderless)
  ;; Type letter a
  ;; 0.091367
  ;; Type letter b
  ;; 0.049451
  ;; Type letter c
  ;; 0.076276
  ;; Type letter d
  ;; 0.069673
  ;; Type letter e
  ;; 0.101040
  ;; Type letter f
  ;; 0.054231
  ;; Type letter g
  ;; 0.065002

#+end_src

To use [[https://github.com/oantolin/orderless][orderless]] filtering:

#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :straight t
    :ensure t
    :commands (orderless-filter))

  (setq fussy-filter-fn 'fussy-filter-orderless)
#+end_src
* Recommendations

User is recommended to try the various scoring functions. See ~fussy-score-fn~.

For speed, ~flx-rs~ or ~fuz/fuz-bin~ will be the most performant but uses Rust.

~flx-rs~ will provide an algorithm that matches the original ~flx~ algorithm.

Below is a sample config that uses ~flx-rs~ for improved performance.

Use ~fuz-bin~ or ~fuz~ for a different matching algorithm but similar performance.

#+begin_src emacs-lisp :tangle yes
  (use-package orderless
    :straight t
    :ensure t
    :commands (orderless-filter))

  (use-package flx-rs
    :ensure t
    :straight
    (flx-rs
     :repo "jcs-elpa/flx-rs"
     :fetcher github
     :files (:defaults "bin"))
    :config
    (setq fussy-score-fn 'flx-rs-score)
    (flx-rs-load-dyn))

  (use-package fussy
    :ensure t
    :straight
    (fussy :type git :host github :repo "jojojames/fussy")
    :config
    (setq fussy-score-fn 'flx-rs-score)
    (setq fussy-filter-fn 'fussy-filter-orderless)

    (push 'fussy completion-styles)
    (setq
     ;; For example, project-find-file uses 'project-files which uses
     ;; substring completion by default. Set to nil to make sure it's using
     ;; flx.
     completion-category-defaults nil
     completion-category-overrides nil)

    ;; `eglot' defaults to flex, so set an override to point to fussy instead.
    (with-eval-after-load 'eglot
      (add-to-list 'completion-category-overrides
                   '(eglot (styles fussy basic)))))

#+end_src
